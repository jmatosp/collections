// generated by collections; DO NOT EDIT

package main

import (
	"fmt"
	"sort"
)

type EligiblePersonFilterFunc func(item Person) bool

func (_c Persons) Filter(eligible EligiblePersonFilterFunc) Persons {
	var result Persons
	for _, item := range _c {
		if !eligible(item) {
			result = append(result, item)
		}
	}
	return result
}

func (_c Persons) All(eligible EligiblePersonFilterFunc) Persons {
	var result Persons
	for _, item := range _c {
		if eligible(item) {
			result = append(result, item)
		}
	}
	return result
}

func (_c Persons) First() Person {
	if len(_c) == 0 {
		return Person{}
	}
	return _c[0]
}

type PersonLessFunc func(item, other Person) bool

func (_c Persons) Sort(less PersonLessFunc) Persons {
	cCopy := _c
	sort.Slice(cCopy, func(i, j int) bool {
		return less(cCopy[i], cCopy[j])
	})
	return cCopy
}

type PersonApplyFunc func(item Person)

func (_c Persons) Apply(applyFunc PersonApplyFunc) {
	for _, item := range _c {
		applyFunc(item)
	}
}

type PersonMapFunc func(item Person) Person

func (_c Persons) Map(mapFunc PersonMapFunc) Persons {
	var result Persons
	_c.Apply(func(item Person) {
		result = append(result, mapFunc(item))
	})
	return result
}

type PersonMapToIntsFunc func(item Person) int

func (_c Persons) MapToInts(mapFunc PersonMapToIntsFunc) []int {
	var result []int
	_c.Apply(func(item Person) {
		result = append(result, mapFunc(item))
	})
	return result
}

type PersonMapToStringsFunc func(item Person) string

func (_c Persons) MapToStrings(mapFunc PersonMapToStringsFunc) []string {
	var result []string
	_c.Apply(func(item Person) {
		result = append(result, mapFunc(item))
	})
	return result
}

func (_c Persons) Println() {
	fmt.Println(_c)
}

func (_c Persons) Print() {
	_c.Apply(func(item Person) {
		fmt.Print(item)
	})
}

func (_c Persons) String() string {
	var result string
	_c.Apply(func(item Person) {
		result = result + fmt.Sprintln(item)
	})
	return result
}

type EligibleOrderFilterFunc func(item Order) bool

func (_c Orders) Filter(eligible EligibleOrderFilterFunc) Orders {
	var result Orders
	for _, item := range _c {
		if !eligible(item) {
			result = append(result, item)
		}
	}
	return result
}

func (_c Orders) All(eligible EligibleOrderFilterFunc) Orders {
	var result Orders
	for _, item := range _c {
		if eligible(item) {
			result = append(result, item)
		}
	}
	return result
}

func (_c Orders) First() Order {
	if len(_c) == 0 {
		return Order{}
	}
	return _c[0]
}

type OrderLessFunc func(item, other Order) bool

func (_c Orders) Sort(less OrderLessFunc) Orders {
	cCopy := _c
	sort.Slice(cCopy, func(i, j int) bool {
		return less(cCopy[i], cCopy[j])
	})
	return cCopy
}

type OrderApplyFunc func(item Order)

func (_c Orders) Apply(applyFunc OrderApplyFunc) {
	for _, item := range _c {
		applyFunc(item)
	}
}

type OrderMapFunc func(item Order) Order

func (_c Orders) Map(mapFunc OrderMapFunc) Orders {
	var result Orders
	_c.Apply(func(item Order) {
		result = append(result, mapFunc(item))
	})
	return result
}

type OrderMapToIntsFunc func(item Order) int

func (_c Orders) MapToInts(mapFunc OrderMapToIntsFunc) []int {
	var result []int
	_c.Apply(func(item Order) {
		result = append(result, mapFunc(item))
	})
	return result
}

type OrderMapToStringsFunc func(item Order) string

func (_c Orders) MapToStrings(mapFunc OrderMapToStringsFunc) []string {
	var result []string
	_c.Apply(func(item Order) {
		result = append(result, mapFunc(item))
	})
	return result
}

func (_c Orders) Println() {
	fmt.Println(_c)
}

func (_c Orders) Print() {
	_c.Apply(func(item Order) {
		fmt.Print(item)
	})
}

func (_c Orders) String() string {
	var result string
	_c.Apply(func(item Order) {
		result = result + fmt.Sprintln(item)
	})
	return result
}
