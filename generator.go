package main

import (
	"bytes"
	"errors"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type templateData struct {
	PackageName string
	Types       []templateDateCollection
}

type templateDateCollection struct {
	Type     string
	ItemType string
}

func generateFile(fileTypes fileTypes) error {
	f, err := os.Create(filename(fileTypes.filename))
	if err != nil {
		return err
	}

	source, err := generateSource(fileTypes)
	if err != nil {
		closeErr := f.Close()
		if closeErr != nil {
			return errors.New("error generating source and closing file")
		}
		return err
	}

	_, err = f.Write([]byte(source))
	if err != nil {
		closeErr := f.Close()
		if closeErr != nil {
			return errors.New("error generating source and closing file")
		}
		return err
	}

	return f.Close()
}

func generateSource(fileTypes fileTypes) (string, error) {
	var aType []templateDateCollection
	for _, item := range fileTypes.sliceTypes {
		aType = append(aType, templateDateCollection{
			Type:     item.name,
			ItemType: item.itemName,
		})
	}
	templateData := templateData{
		PackageName: fileTypes.packageName,
		Types:       aType,
	}

	w := &bytes.Buffer{}
	err := collection.Execute(w, templateData)
	if err != nil {
		return "", err
	}

	return w.String(), nil
}

func filename(originalFilename string) string {
	extension := filepath.Ext(originalFilename)
	namePart := strings.TrimSuffix(originalFilename, extension)
	return strings.ToLower(namePart) + "_collection.go"
}

var collection = template.Must(template.New("collection").Parse(collectionTemplate))

const collectionTemplate = `// generated by collections; github.com/jmatosp/collections; DO NOT EDIT

package {{.PackageName}}

import (
	"fmt"
	"sort"
)
{{ range $index, $value := .Types }}
type Eligible{{.ItemType}}FilterFunc func(item {{.ItemType}}) bool

func (_c {{.Type}}) Filter(eligible Eligible{{.ItemType}}FilterFunc) {{.Type}} {
	var result {{.Type}}
	for _, item := range _c {
		if eligible(item) {
			result = append(result, item)
		}
	}
	return result
}

func (_c {{.Type}}) First() {{.ItemType}} {
	if len(_c) == 0 {
		return {{.ItemType}}{}
	}
	return _c[0]
}

type {{.ItemType}}LessFunc func(item, other {{.ItemType}}) bool

func (_c {{.Type}}) Sort(less {{.ItemType}}LessFunc) {{.Type}} {
	cCopy := _c
	sort.Slice(cCopy, func(i, j int) bool {
		return less(cCopy[i], cCopy[j])
	})
	return cCopy
}

type {{.ItemType}}ApplyFunc func(item {{.ItemType}})

func (_c {{.Type}}) Apply(applyFunc {{.ItemType}}ApplyFunc) {
	for _, item := range _c {
		applyFunc(item)
	}
}

type {{.ItemType}}MapFunc func(item {{.ItemType}}) {{.ItemType}}

func (_c {{.Type}}) Map(mapFunc {{.ItemType}}MapFunc) {{.Type}} {
	var result {{.Type}}
	_c.Apply(func(item {{.ItemType}}) {
		result = append(result, mapFunc(item))
	})
	return result
}

type {{.ItemType}}MapToIntsFunc func(item {{.ItemType}}) int

func (_c {{.Type}}) MapToInts(mapFunc {{.ItemType}}MapToIntsFunc) []int {
	var result []int
	_c.Apply(func(item {{.ItemType}}) {
		result = append(result, mapFunc(item))
	})
	return result
}

type {{.ItemType}}MapToStringsFunc func(item {{.ItemType}}) string

func (_c {{.Type}}) MapToStrings(mapFunc {{.ItemType}}MapToStringsFunc) []string {
	var result []string
	_c.Apply(func(item {{.ItemType}}) {
		result = append(result, mapFunc(item))
	})
	return result
}

func (_c {{.Type}}) Println() {
	fmt.Println(_c)
}

func (_c {{.Type}}) Print() {
	_c.Apply(func(item {{.ItemType}}) {
		fmt.Print(item)
	})
}

func (_c {{.Type}}) String() string {
	var result string
	_c.Apply(func(item {{.ItemType}}) {
		result = result + fmt.Sprintln(item)
	})
	return result
}
{{ end }}`
